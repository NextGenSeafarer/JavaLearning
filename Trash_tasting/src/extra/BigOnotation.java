package extra;

public class BigOnotation {

    /*
    Big O notation - это условный показатель скорости выполнения алгоритма
    Существует их множество, но более часто используемыми являются 3 :
    O(1) || O(n) ||  O(log n)

    O(1) - постоянная скорость выполнения или же, можно сказать мгновенная (считается самой быстрой из этих 3)
    метод get в List или получение элемента массива происходит с такой скоростью.
    Разберем на примере
    int [] array = new int [4];
    В памяти выделяется область размером 4 байта 4 раза (т.к. у нас размерность массива = 4, а int хранит 4 байта)
    |  |  |  |  |
   12          26
    т.е. первый индекс будет, к примеру, 12, Java уже знает, что на 12 байте будет записан array[0]
    array = { 1, 5, 6, -3 };
    Мы инициализировали массив
    Теперь, чтобы найти элемент, допустим, int [2] Java будет прибавлять к позиции int[0] + 2(index) multiply by 4(место (в байтах), которое занимает каждый элемент)
    т.е
    12 + 2 x 4 = 20
    Искомый элемент в массиве под индексом 2 будет на 20 байте памяти, куда записан элемент равный 6;
    array[2] = 6; - эта операция будет произведена со скоростью O(1)

    То же самое будет с ArrayList и методом get.

    Что касается String - нужно понимать, что массив строк будет хранить не строки, а ссылки на эти строки.

    String [] stringArray = new String [5];
    Java выделяет в памяти 5 раз по 8 байт (потому что ссылочные типы данных хранятся в 8 байтах)

    String [0] = " a ";
    String [1] = " b ";
    String [2] = " c ";
    String [3] = " d ";
    String [4] = " e ";

    |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
   50          55             60             65             70             75             80             85             90

   |         a           |             b         |            c          |            d         |            e          |
   ^                     ^
   |       ссылка        |       ссылка         |       ссылка          |       ссылка         |       ссылка          |

   Где - то в другом месте в памяти создается сам объект, который будет занимать уже необходимое место, чтобы вместить
   String, которую ввел пользователь.

   Мы хотим вывести элемент String [1]
   String [0] находится на 50 байте, значит 50 + 8 x index (1) = 58
   На 58 байте хранится ссылка на String "b", которая и вернет нам "b" уже из какого - то другого участка памяти.


   + String Pool - место, выделяемое в памяти для хранения String, находится внутри кучи, но структурировано, чтобы не
   занимать место в памяти повторяющимися строками создается String Pool, а если где - то будет создана точно такая же строка -
   то ещё раз в память она записана не будет, а будет создана ссылка, поэтому 3 одинаковых массива строк будут иметь ссылки на одни
   и те же объекты типа String из String pool.

   String s1 = "Cat";
   String s2 = "Cat";
   System.out.println (s1 == s2);
   В консоли будет true, т.к ссылки одинаковые, а == сравнивает как раз таки ссылки.
   Для сравнения самих срок нужно использовать метод .equals


   Говоря о скорости LinkedList и ArrayList, ArrayList будет почти всегда более производительным чем LinkedList.
   .get для ArrayList - O(1), для LinkedList - O(n) - линейная скорость, т.к нужно пройти по всем элементам с 0 до искомого
   И так для всего, кроме вставки в начало коллекции
   При добавлении элемента в начало коллекции для LinkedList будет O(1) - потому что поменяется ссылка только для нулевого
   элемента, остальные останутся нетронутыми.
   Но у ArrayList при такой операции будет сдвигаться весь массив вправо + изменять размерность.
   Таким образом единственная более выгодная по производительности операция - добавление в начало коллекции для LinkedList.

   */



}
